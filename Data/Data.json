kk


export default ContactAdd;
const sendDataToAPI = async () => {
  try {
    if (!response.ok) {
      throw new Error('Network response was not ok');
    }
    const response = await fetch('URL', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify(e.Changes[0].data.SystemID),
    });
    const result = await response.json();
    console.log('Success:', result);
  } catch (error) {
    console.error('Error:', error);
  }
};



import React, { useContext, useEffect, useState } from 'react';
import DataGrid, { Column, Editing, Button as GridButton, ToolbarItem } from 'devextreme-react/data-grid';
import DateBox from 'devextreme-react/date-box';
import { Button } from 'devextreme-react/button';
import 'devextreme/dist/css/dx.light.css';
import { CheckContext } from '../../CustomHook'; // Adjust the path as needed
import { useNavigate } from 'react-router-dom';
import notify from 'devextreme/ui/notify';
import { FontAwesomeIcon } from '@fortawesome/react-fontawesome';
import { faSpinner, faEdit } from '@fortawesome/free-solid-svg-icons';
import './Adminstration.css';
import { TagBox } from 'devextreme-react';

interface System {
  systemID: number;
  pirid: number | null;
  systemName: string;
  country: string;
  startTime: string | null;
  endTime: string | null;
  isRunning: boolean;
}

type SystemField = keyof System;

const GridTable: React.FC = () => {
  const { setDateTime, setSelectedModule } = useContext(CheckContext);
  const navigate = useNavigate();
  const [systems, setSystems] = useState<System[]>([]);
  const [activeModule, setActiveModule] = useState('selectedModule');
  const [editingRowKey, setEditingRowKey] = useState<number | null>(null);

  useEffect(() => {
    const fetchData = async () => {
      try {
        const response = await fetch(process.env.REACT_APP_BACKEND_API + '/api/Adminstration');
        const data: System[] = await response.json();
        setSystems(data);
      } catch (error) {
        console.error('Error fetching data:', error);
      }
    };
    fetchData();
  }, []);

  useEffect(() => {
    const savedModule = localStorage.getItem('selectedModule');
    if (savedModule) {
      setSelectedModule(savedModule);
      setActiveModule(savedModule);
    }
  }, [setSelectedModule]);

  const handleDateChange = (index: number, field: SystemField, value: Date | null) => {
    const today = new Date().setHours(0, 0, 0, 0);
    const newSystems = [...systems];
    const system = newSystems[index];

    if (field === 'startTime') {
      if (value && value.getTime() < today) {
        notify('Start date cannot be in the past', 'warning', 2000);
        return;
      }
      system[field] = value ? value.toISOString() : null;
    } else if (field === 'endTime') {
      if (!system.startTime) {
        notify('Please select a start date first', 'warning', 2000);
        return;
      }
      if (value && value.getTime() < new Date(system.startTime).getTime()) {
        notify('End date must be greater than or equal to the start date', 'warning', 2000);
        return;
      }
      system[field] = value ? value.toISOString() : null;
    }

    newSystems[index] = system;
    setSystems(newSystems);
  };

  const dateCellRender = (cellData: any, dateField: SystemField) => {
    const index = systems.findIndex(system => system.systemID === cellData.data.systemID);
    const today = new Date();
    const isEditing = cellData.data.systemID === editingRowKey;

    return (
      <DateBox
        placeholder='Please Enter Date'
        type='datetime'
        value={cellData.data[dateField] ? new Date(cellData.data[dateField]) : undefined}
        min={dateField === 'startTime' ? today : cellData.data.startTime ? new Date(cellData.data.startTime) : today}
        onValueChanged={(e) => handleDateChange(index, dateField, e.value)}
        displayFormat="yyyy-MM-dd - HH:mm"
        disabled={!isEditing}
        showClearButton={true}
        onFocusIn={(e) => (e.component.option('placeholder', 'Please Enter Date'))}
      />
    );
  };

  const systemNameCellRender = (cellData: any) => {
    return (
      <div>
        {cellData.data.systemName}
        {cellData.data.isRunning && <FontAwesomeIcon icon={faSpinner} spin className='spinner' />}
      </div>
    );
  };

  const actionCellRender = (cellData: any) => {
    if (cellData.data.isRunning) {
      return (
        <>
          <Button icon="clear" onClick={() => onStopClick(cellData.data.systemID)} />
          <Button icon="download" />
          <Button width={100} text="details" type="normal" stylingMode="outlined" />
        </>
      );
    }
  };

  const countryCellRender = (cellData: any) => (
    <TagBox readOnly value={cellData.data.country.split(",")} dataSource={[]} showClearButton={false} className='countryTB' />
  );

  const onStopClick = (systemID: number) => {
    const updatedSystems = systems.map(system => {
      if (system.systemID === systemID) {
        return { ...system, isRunning: false };
      }
      return system;
    });

    setSystems(updatedSystems);
  };

  const onRowUpdating = (e: any) => {
    const { newData, oldData } = e;
    const today = new Date().setHours(0, 0, 0, 0);

    if (newData.startTime && new Date(newData.startTime).getTime() < today) {
      e.cancel = true;
      notify('Start date cannot be in the past', 'warning', 2000);
    } else if (!newData.startTime && !oldData.startTime) {
      e.cancel = true;
      notify('Start date is required', 'error', 2000);
    } else if (newData.endTime && new Date(newData.endTime).getTime() < new Date(newData.startTime || oldData.startTime).getTime()) {
      e.cancel = true;
      notify('End date must be greater than or equal to the start date', 'warning', 2000);
    } else if (!newData.endTime && !oldData.endTime) {
      e.cancel = true;
      notify('End date is required', 'error', 2000);
    }
  };

  const onEditingStart = (e: any) => {
    setEditingRowKey(e.key);
  };

  const onSaved = (e: any) => {
    setEditingRowKey(null);
  };

  const onEditCanceling = (e: any) => {
    setEditingRowKey(null);
  };

  return (
    <DataGrid
      dataSource={systems}
      showBorders={true}
      columnAutoWidth={true}
      rowAlternationEnabled={true}
      onRowUpdating={onRowUpdating}
      onEditingStart={onEditingStart}
      onSaved={onSaved}
      onEditCanceling={onEditCanceling}
    >
      <Editing
        mode="row"
        allowUpdating={true}
        useIcons={true}
        startEditAction="click"
      />

      <Column
        dataField="systemName"
        caption="System"
        cellRender={systemNameCellRender}
        width={"10%"}
        allowEditing={false} />

      <Column
        dataField="country"
        caption="Country"
        allowEditing={false}
        width={"20%"}
        cellRender={countryCellRender} />

      <Column
        width={"25%"}
        dataField="startTime"
        caption="Start Date"
        dataType='datetime'
        cellRender={(cellData) => dateCellRender(cellData, 'startTime')}
      />

      <Column
        width={"20%"}
        dataField="endTime"
        caption="End Date"
        dataType='datetime'
        cellRender={(cellData) => dateCellRender(cellData, 'endTime')}
      />

      <Column type="buttons">
        <GridButton 
          name="edit" 
          icon="edit" 
          visible={(e) => !e.row.data.isRunning && (!e.row.data.startTime || new Date(e.row.data.startTime).getTime() > new Date().getTime())} 
        />
      </Column>

      <Column
        caption="Action"
        cellRender={actionCellRender}
        allowEditing={false}
      />
    </DataGrid>
  );
};

export default GridTable;
