import React, { useContext, useEffect, useState } from 'react';
import DataGrid, { Column, Editing, FilterRow, Pager, Paging, Button as GridButton } from 'devextreme-react/data-grid';
import DateBox from 'devextreme-react/date-box';
import { Button } from 'devextreme-react/button';
import 'devextreme/dist/css/dx.light.css';
import { CheckContext } from '../../CustomHook'; // Adjust the path as needed
import notify from 'devextreme/ui/notify';
import axios from 'axios';

interface System {
  systemID: number;
  pirid: number | null;
  systemName: string;
  country: string;
  startDate: Date | null;
  endDate: Date | null;
  isRunning: boolean;
}

type SystemField = keyof System;

const GridTable: React.FC = () => {
  const { setDateTime, setSelectedModule } = useContext(CheckContext);
  const [systems, setSystems] = useState<System[]>([]);
  const [editingRowKey, setEditingRowKey] = useState<number | null>(null);
  const [editingMode, setEditingMode] = useState<string | null>(null);

  useEffect(() => {
    const fetchData = async () => {
      try {
        const response = await axios.get(`${process.env.REACT_APP_BACKEND_API}api/Adminstration`);
        setSystems(response.data);
      } catch (error) {
        console.error('Error fetching data:', error);
      }
    };
    fetchData();
  }, []);

  const dateCellRender = (cellData: any, dateField: SystemField) => (
    <DateBox
      placeholder='Please enter date'
      type='datetime'
      value={cellData.data[dateField] ? new Date(cellData.data[dateField]) : ""}
      readOnly
    />
  );

  const systemNameCellRender = (cellData: any) => (
    <div className="flex-container-system-name">
      <div>{cellData.data.systemName}</div>
      <div>{cellData.data.isRunning && <div className="running-text">RUNNING...</div>}</div>
    </div>
  );

  const actionCellRender = (cellData: any) => (
    <>
      {cellData.data.isRunning && <Button icon="clear" onClick={() => onStopClick(cellData.data.systemID)} />}
    </>
  );

  const countryCellRender = (cellData: any) => (
    <TagBox readOnly value={cellData.data.country.split(",")} dataSource={[]} showClearButton={false} stylingMode="underlined" />
  );

  const onStopClick = (systemID: number) => {
    const updatedSystems = systems.map(system => (system.systemID === systemID ? { ...system, isRunning: false } : system));
    setSystems(updatedSystems);
  };

  const onRowUpdating = (e: any) => {
    const { newData, oldData } = e;
    const today = new Date().setHours(0, 0, 0, 0);

    if (newData.startDate && new Date(newData.startDate).getTime() < today) {
      e.cancel = true;
      notify('Start date cannot be in the past', 'warning', 2000);
    } else if (!newData.startDate && !oldData.startDate) {
      e.cancel = true;
      notify('Start date is required', 'error', 2000);
    } else if (newData.endDate && new Date(newData.endDate).getTime() < new Date(newData.startDate || oldData.startDate).getTime()) {
      e.cancel = true;
      notify('End date must be greater than or equal to the start date', 'warning', 2000);
    } else if (!newData.endDate && !oldData.endDate) {
      e.cancel = true;
      notify('End date is required', 'error', 2000);
    }
  };

  const sendDataToAPI = async (systemID: number, startDate: string | null, endDate: string | null, mode: string) => {
    try {
      await fetch(`${process.env.REACT_APP_BACKEND_API}api/Adminstration/${mode}pir`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json'
        },
        body: JSON.stringify({ systemID, startDate, endDate }),
      });
    } catch (error) {
      console.log('Error:', error);
    }
  };

  const OnEditingStart = (e: any) => {
    setEditingRowKey(e.key);
    if (!e.data.startDate && !e.data.endDate) {
      setEditingMode("insert");
    } else {
      setEditingMode("update");
    }
  };

  const OnSaved = (e: any) => {
    setEditingRowKey(null);
    const systemID = e.changes[0].data.systemID;
    const startDate = e.changes[0].data.startDate || null;
    const endDate = e.changes[0].data.endDate || null;

    if (editingMode) {
      sendDataToAPI(systemID, startDate, endDate, editingMode);
    }

    setEditingMode(null);
  };

  const onEditCanceling = (e: any) => {
    setEditingRowKey(null);
    setEditingMode(null);
  };

  return (
    <DataGrid
      dataSource={systems}
      onRowUpdating={onRowUpdating}
      onEditingStart={OnEditingStart}
      onSaved={OnSaved}
      onEditCanceling={onEditCanceling}
      hoverStateEnabled={true}
    >
      <Editing
        mode="row"
        allowUpdating={true}
        useIcons={true}
        startEditAction="click"
      />
      <FilterRow visible={true} />
      <Paging defaultPageSize={50} />
      <Pager
        visible={true}
        allowedPageSizes={[10, 20, 50]}
        showPageSizeSelector={true}
        showInfo={true}
        showNavigationButtons={true}
      />

      <Column
        dataField="systemName"
        caption="SYSTEM"
        cellRender={systemNameCellRender}
        width={"20%"}
        allowEditing={false}
      />
      <Column
        dataField="country"
        caption="COUNTRY"
        allowEditing={false}
        width={"30%"}
        cellRender={countryCellRender}
      />
      <Column
        width={"30%"}
        dataField="startDate"
        caption="START DATE"
        dataType="datetime"
        cellRender={(cellData) => dateCellRender(cellData, 'startDate')}
        editorOptions={{
          displayFormat: "dd/MM/yyyy HH:mm",
          showClearButton: true,
          stylingMode: "underlined"
        }}
      />
      <Column
        width={"30%"}
        dataField="endDate"
        caption="END DATE"
        dataType="datetime"
        cellRender={(cellData) => dateCellRender(cellData, 'endDate')}
        editorOptions={{
          displayFormat: "dd/MM/yyyy HH:mm",
          showClearButton: true,
          stylingMode: "underlined"
        }}
      />
      <Column type="buttons" caption="ACTIONS">
        <GridButton name="edit" icon="edit" />
        <GridButton name="edit" icon="square" cssClass={"action-stop"} onClick={() => null} disabled={(e) => !e.row.data.isRunning} />
        <GridButton name="edit" icon="chart" onClick={() => null} disabled={(e) => !e.row.data.isRunning} />
        <GridButton name="edit" icon="toolbox" onClick={() => null} disabled={(e) => !e.row.data.isRunning} />
        <GridButton name="edit" icon="download" onClick={() => null} disabled={(e) => !e.row.data.isRunning} />
      </Column>
    </DataGrid>
  );
};

export default GridTable;
